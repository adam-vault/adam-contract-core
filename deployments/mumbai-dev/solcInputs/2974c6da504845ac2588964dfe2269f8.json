{
  "language": "Solidity",
  "sources": {
    "contracts/PolygonChainlinkPriceGateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.7;\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@chainlink/contracts/src/v0.8/Denominations.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol\";\n\nimport \"./base/PriceGateway.sol\";\nimport \"./lib/Constant.sol\";\n\n/**\n@title PolygonChainlinkPriceGateway\n@dev A price gateway that uses Chainlink price feeds to calculate asset prices in terms of base tokens.\nIt supports ETH, WETH, MATIC, WMATIC and other ERC20 tokens as assets or base tokens.\nThis contract is inherited from the PriceGateway base contract, \nwhich provides basic functions to check the support of the pair and calculate asset prices.\n*/\n\ncontract PolygonChainlinkPriceGateway is PriceGateway {\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    string public constant override name = \"Polygon Chainlink Price Gateway\";\n\n    error StaleRoundId(uint80 roundID, uint80 answeredInRound);\n    error StaleTimestamp(uint256 currentTimeStamp, uint256 updatedAtTimeStamp);\n    error InvaildDecimal(uint8 decimals);\n    constructor() {\n    }\n\n    /// @notice inherited from PriceGateway, help to check the imported pair support or not\n    /// @dev Custom price gateway is allowed, but need to implement priceGateway.sol and set by govern\n    /// @param asset the asset token address, support ETH , WETH, MATIC, WMATIC and other ERC20\n    /// @param base the base token address, support ETH , WETH, MATIC, WMATIC and other ERC20\n    /// @return boolean Is support or not\n    function isSupportedPair(address asset, address base)\n        public\n        virtual\n        view\n        override\n        returns (bool)\n    {\n        return canResolvePrice(asset) && canResolvePrice(base);\n    }\n\n    /// @notice inherited from PriceGateway, to cal the asset price base on different token\n    /// @dev For those outside contract , Please used this as the entry point\n    /// @dev this Function will help to route the calculate to other cal function,\n    /// @dev Please do not directly call the below cal function\n    /// @param asset the asset token address, support ETH , WETH, MATIC, WMATIC and other ERC20\n    /// @param base the base token address, support ETH , WETH, MATIC, WMATIC and other ERC20\n    /// @param amount the amount of asset, in asset decimal\n    /// @return uint256 the Asset Price in term of base token in base token decimal\n    function assetPrice(\n        address asset,\n        address base,\n        uint256 amount\n    ) public view virtual override returns (uint256) {\n        asset = asset == _WETH9() ? Denominations.ETH : asset;\n        base = base == _WETH9() ? Denominations.ETH : base;\n        asset = asset == _WMATIC() ? Constant.MATIC_ADDRESS : asset;\n        base = base == _WMATIC() ? Constant.MATIC_ADDRESS : base;\n        // Feed Registry doesn't provide any WETH Price Feed, redirect to ETH case here\n        // Feed Registry doesn't provide any WMATIC Price Feed, redirect to MATIC case here\n\n        if (asset == base) return amount;\n\n        if (base == Denominations.USD) {\n            return assetUSDPrice(asset, amount);\n        }\n\n        if (asset == Denominations.USD) {\n            return usdAssetPrice(base, amount);\n        }\n\n        return derivedAssetPrice(asset, base, amount);\n    }\n\n    /// @notice Get Asset Price in Term of USD\n    /// @dev Get the rate in Chainlink and scale the Price to decimal 8\n    /// @param asset the asset token address, support ETH , WETH, MATIC, WMATIC and other ERC20\n    /// @param amount Asset Amount in term of asset's decimal\n    /// @return uint256 the Asset Price in term of USD with hardcoded decimal 8\n    function assetUSDPrice(address asset, uint256 amount)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (asset == Denominations.USD) return amount;\n        asset = asset == _WETH9() ? Denominations.ETH : asset;\n        asset = asset == _WMATIC() ? Constant.MATIC_ADDRESS : asset;\n\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = FeedRegistryInterface(Constant.FEED_REGISTRY).latestRoundData(\n                asset,\n                Denominations.USD\n            );\n        uint8 priceDecimals = FeedRegistryInterface(Constant.FEED_REGISTRY)\n            .decimals(asset, Denominations.USD);\n\n\n        if (answeredInRound < roundID) {\n            revert StaleRoundId(roundID, answeredInRound);\n        }\n        if (block.timestamp > updatedAt + Constant.STALE_PRICE_DELAY) {\n            revert StaleTimestamp(block.timestamp, updatedAt);\n        }\n\n        price = scalePrice(\n            price,\n            priceDecimals,\n            8 /* USD decimals */\n        );\n\n        if (price > 0) {\n            // return price with decimal = price Decimal (8) + amount decimal (Asset decimal) - Asset decimal = price decimal(8)\n            return\n                (uint256(price) * amount) /\n                10**assetDecimals(asset);\n        }\n\n        return 0;\n    }\n\n    /// @notice Get USD Price in term of Asset\n    /// @dev Get the rate in Chainlink and scale the Price to asset decimal\n    /// @param asset the asset token address, support ETH , WETH, MATIC, WMATIC and other ERC20, used as base token address\n    /// @param usdAmount Usd Amount with 8 decimal (arbitrum)\n    /// @return uint256 the price by using asset as base with assets decimal\n    function usdAssetPrice(address asset, uint256 usdAmount)\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        if (asset == Denominations.USD) return usdAmount;\n        asset = asset == _WETH9() ? Denominations.ETH : asset;\n        asset = asset == _WMATIC() ? Constant.MATIC_ADDRESS : asset;\n        (\n            uint80 roundID,\n            int256 price,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = FeedRegistryInterface(Constant.FEED_REGISTRY).latestRoundData(\n                asset,\n                Denominations.USD\n            );\n        uint8 priceDecimals = FeedRegistryInterface(Constant.FEED_REGISTRY)\n            .decimals(asset, Denominations.USD);\n\n        if (answeredInRound < roundID) {\n            revert StaleRoundId(roundID, answeredInRound);\n        }\n        if (block.timestamp > updatedAt + Constant.STALE_PRICE_DELAY) {\n            revert StaleTimestamp(block.timestamp, updatedAt);\n        }\n\n        price = scalePrice(\n            price,\n            priceDecimals,\n            8 /* USD decimals */\n        );\n        if (price > 0) {\n            // return price with decimal = 8 + asset Decimal - price Decimal (8) = asset Decimal\n            return\n                (usdAmount * (10**assetDecimals(asset))) /\n                uint256(price);\n        }\n\n        return 0;\n    }\n\n    function derivedAssetPrice(\n        address asset,\n        address base,\n        uint256 amount\n    ) public view virtual returns (uint256) {\n        int256 rate = getDerivedPrice(\n            asset,\n            base,\n            18 /* ETH decimals */\n        );\n\n        if (rate > 0) {\n            return\n                uint256(\n                    scalePrice(\n                        int256(rate) * int256(amount),\n                        18 + assetDecimals(asset),\n                        assetDecimals(base)\n                    )\n                );\n        }\n        return 0;\n    }\n\n    function getDerivedPrice(\n        address _base,\n        address _quote,\n        uint8 _decimals\n    ) internal view virtual returns (int256) {\n        if (_decimals <= uint8(0) || _decimals > uint8(18)) {\n            revert InvaildDecimal(_decimals);\n        }\n        int256 decimals = int256(10**uint256(_decimals));\n        (\n            uint80 _baseRoundID,\n            int256 basePrice,\n            ,\n            uint256 _baseUpdatedAt,\n            uint80 _baseAnsweredInRound\n        ) = FeedRegistryInterface(Constant.FEED_REGISTRY).latestRoundData(\n                _base,\n                Denominations.USD\n            );\n\n        if (_baseAnsweredInRound < _baseRoundID) {\n            revert StaleRoundId(_baseAnsweredInRound, _baseRoundID);\n        }\n        if (block.timestamp > _baseUpdatedAt + Constant.STALE_PRICE_DELAY) {\n            revert StaleTimestamp(block.timestamp, _baseUpdatedAt);\n        }\n\n        uint8 baseDecimals = FeedRegistryInterface(Constant.FEED_REGISTRY)\n            .decimals(_base, Denominations.USD);\n        basePrice = scalePrice(basePrice, baseDecimals, _decimals);\n        (\n            uint80 _quoteRoundID,\n            int256 quotePrice,\n            ,\n            uint256 _quoteUpdatedAt,\n            uint80 _quoteAnsweredInRound\n        ) = FeedRegistryInterface(Constant.FEED_REGISTRY).latestRoundData(\n                _quote,\n                Denominations.USD\n            );\n        if (_quoteAnsweredInRound < _quoteRoundID) {\n            revert StaleRoundId(_quoteAnsweredInRound, _quoteRoundID);\n        }\n        if (block.timestamp > _quoteUpdatedAt + Constant.STALE_PRICE_DELAY) {\n            revert StaleTimestamp(block.timestamp, _quoteUpdatedAt);\n        }\n\n        uint8 quoteDecimals = FeedRegistryInterface(Constant.FEED_REGISTRY)\n            .decimals(_quote, Denominations.USD);\n        quotePrice = scalePrice(quotePrice, quoteDecimals, _decimals);\n\n        return (basePrice * decimals) / quotePrice;\n    }\n\n    function scalePrice(\n        int256 _price,\n        uint8 _priceDecimals,\n        uint8 _decimals\n    ) internal pure virtual returns (int256) {\n        \n        if (_priceDecimals < _decimals) {\n            return _price * int256(10**uint256(_decimals - _priceDecimals));\n        } else if (_priceDecimals > _decimals) {\n            return _price / int256(10**uint256(_priceDecimals - _decimals));\n        }\n        return _price;\n    }\n\n    /// @notice Check if the asset is supported by the feed registry\n    /// @param asset The asset token address, support ETH, WETH, MATIC, WMATIC and other ERC20\n    /// @return boolean True if the asset is supported, false otherwise\n    function canResolvePrice(address asset) internal view returns (bool) {\n        if (asset == Denominations.USD) return true;\n\n        if (asset == _WETH9()) {\n            // Feed Registry doesn't provide any WETH Price Feed, redirect to ETH case here\n            asset = Denominations.ETH;\n        }\n        if (asset == _WMATIC()) {\n            // Feed Registry doesn't provide any WETH Price Feed, redirect to ETH case here\n            asset = Constant.MATIC_ADDRESS;\n        }\n\n        try\n            FeedRegistryInterface(Constant.FEED_REGISTRY).getFeed(\n                asset,\n                Denominations.USD\n            )\n        {\n            return true;\n        } catch (bytes memory) {\n            return false;\n        }\n    }\n\n    function assetDecimals(address asset) public view virtual returns (uint8) {\n        if (asset == Denominations.ETH) return 18;\n        if (asset == Denominations.USD) return 8;\n        try IERC20Metadata(asset).decimals() returns (uint8 _decimals) {\n            return _decimals;\n        } catch {\n            return 0;\n        }\n    }\n\n    function _WETH9() internal pure returns (address) {\n        return Constant.WETH_ADDRESS;\n    }\n\n    function _WMATIC() internal pure returns (address) {\n        return Constant.WMATIC_ADDRESS;\n    }\n\n    uint256[50] private __gap;\n}"
    },
    "contracts/base/PriceGateway.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity 0.8.7;\n\nabstract contract PriceGateway {\n    function isSupportedPair(address asset, address base)\n        public\n        view\n        virtual\n        returns (bool)\n    {}\n\n    function assetPrice(\n        address asset,\n        address base,\n        uint256 amount\n    ) public view virtual returns (uint256) {}\n\n    function name() external virtual returns (string memory);\n}"
    },
    "contracts/lib/Constant.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.7;\n\nlibrary Constant {\n    bytes32 public constant BEACON_NAME_DAO = bytes32(keccak256(\"adam.dao\"));\n    bytes32 public constant BEACON_NAME_MEMBERSHIP = bytes32(keccak256(\"adam.dao.membership\"));\n    bytes32 public constant BEACON_NAME_MEMBER_TOKEN = bytes32(keccak256(\"adam.dao.member_token\"));\n    bytes32 public constant BEACON_NAME_LIQUID_POOL = bytes32(keccak256(\"adam.dao.liquid_pool\"));\n    bytes32 public constant BEACON_NAME_GOVERN = bytes32(keccak256(\"adam.dao.govern\"));\n    bytes32 public constant BEACON_NAME_TEAM = bytes32(keccak256(\"adam.dao.team\"));\n    bytes32 public constant BEACON_NAME_ACCOUNTING_SYSTEM = bytes32(keccak256(\"adam.dao.accounting_system\"));\n\n    address public constant WETH_ADDRESS = 0x40155AD14A14C6F7A3116dafb279160D9761c606;\n    address public constant MATIC_ADDRESS = 0x0000000000000000000000000000000000001010;\n    address public constant WMATIC_ADDRESS = 0x9c3C9283D3e44854697Cd22D3Faa240Cfb032889;\n    address public constant UNISWAP_ROUTER = 0x68b3465833fb72A70ecDF485E0e4C7bD8665Fc45;\n    address public constant FEED_REGISTRY = 0xe74B6321545aD397E08AdB12d83983eB8e6F4062;\n    address public constant BRIDGE_CURRENCY = 0x0000000000000000000000000000000000000348;\n    uint public constant STALE_PRICE_DELAY = 86400;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/Denominations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nlibrary Denominations {\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n  address public constant BTC = 0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB;\n\n  // Fiat currencies follow https://en.wikipedia.org/wiki/ISO_4217\n  address public constant USD = address(840);\n  address public constant GBP = address(826);\n  address public constant EUR = address(978);\n  address public constant JPY = address(392);\n  address public constant KRW = address(410);\n  address public constant CNY = address(156);\n  address public constant AUD = address(36);\n  address public constant CAD = address(124);\n  address public constant CHF = address(756);\n  address public constant ARS = address(32);\n  address public constant PHP = address(608);\n  address public constant NZD = address(554);\n  address public constant SGD = address(702);\n  address public constant NGN = address(566);\n  address public constant ZAR = address(710);\n  address public constant RUB = address(643);\n  address public constant INR = address(356);\n  address public constant BRL = address(986);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/FeedRegistryInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\npragma abicoder v2;\n\nimport \"./AggregatorV2V3Interface.sol\";\n\ninterface FeedRegistryInterface {\n  struct Phase {\n    uint16 phaseId;\n    uint80 startingAggregatorRoundId;\n    uint80 endingAggregatorRoundId;\n  }\n\n  event FeedProposed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed proposedAggregator,\n    address currentAggregator,\n    address sender\n  );\n  event FeedConfirmed(\n    address indexed asset,\n    address indexed denomination,\n    address indexed latestAggregator,\n    address previousAggregator,\n    uint16 nextPhaseId,\n    address sender\n  );\n\n  // V3 AggregatorV3Interface\n\n  function decimals(address base, address quote) external view returns (uint8);\n\n  function description(address base, address quote) external view returns (string memory);\n\n  function version(address base, address quote) external view returns (uint256);\n\n  function latestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function getRoundData(\n    address base,\n    address quote,\n    uint80 _roundId\n  )\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // V2 AggregatorInterface\n\n  function latestAnswer(address base, address quote) external view returns (int256 answer);\n\n  function latestTimestamp(address base, address quote) external view returns (uint256 timestamp);\n\n  function latestRound(address base, address quote) external view returns (uint256 roundId);\n\n  function getAnswer(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (int256 answer);\n\n  function getTimestamp(\n    address base,\n    address quote,\n    uint256 roundId\n  ) external view returns (uint256 timestamp);\n\n  // Registry getters\n\n  function getFeed(address base, address quote) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseFeed(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function isFeedEnabled(address aggregator) external view returns (bool);\n\n  function getPhase(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (Phase memory phase);\n\n  // Round helpers\n\n  function getRoundFeed(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (AggregatorV2V3Interface aggregator);\n\n  function getPhaseRange(\n    address base,\n    address quote,\n    uint16 phaseId\n  ) external view returns (uint80 startingRoundId, uint80 endingRoundId);\n\n  function getPreviousRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 previousRoundId);\n\n  function getNextRoundId(\n    address base,\n    address quote,\n    uint80 roundId\n  ) external view returns (uint80 nextRoundId);\n\n  // Feed management\n\n  function proposeFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  function confirmFeed(\n    address base,\n    address quote,\n    address aggregator\n  ) external;\n\n  // Proposed aggregator\n\n  function getProposedFeed(address base, address quote)\n    external\n    view\n    returns (AggregatorV2V3Interface proposedAggregator);\n\n  function proposedGetRoundData(\n    address base,\n    address quote,\n    uint80 roundId\n  )\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function proposedLatestRoundData(address base, address quote)\n    external\n    view\n    returns (\n      uint80 id,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  // Phases\n  function getCurrentPhaseId(address base, address quote) external view returns (uint16 currentPhaseId);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV2V3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AggregatorInterface.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\ninterface AggregatorV2V3Interface is AggregatorInterface, AggregatorV3Interface {}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}